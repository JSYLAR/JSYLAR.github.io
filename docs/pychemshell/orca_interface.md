_init_.py
```
import re
import os.path
import math
from numpy         import full, zeros
from ...base       import errors
from ...utils      import fileutils
from ..qm          import _QM
from ...data       import atomicdata, unitconvert

class ORCA(_QM):
    '''Interface to ORCA'''

    _attrs = {
               'auxbasis'              :'',
               'basisspec'             : False,
               # YL 09/03/2021: (suggested by HMS) with ORCA it's always encouraged to use "TightSCF" although "NormalSCF" is the default
               # YL NB 09/03/2021: but we may change the option's keyword in the future to make it uniform for all interfaces (currently other interfaces use "threshold=1.0e-6")
               'convergence'           :"TightSCF",
			   'exchange'              :"",
               'cosmo'                 : None,
               'd3'                    : False,
			   'd4'                    : False,
               'enerflag'              : 1,
               'energy_correction'     : 0.0,
               'eroots'                : 1,
               'estate'                : 1,
               'excited'               : False,
               'explicit'              : False,
               'exp_list'              : [],
               'guess'                 : "Hueckel",
               'image'                 : None,
               'input'                 :"_orca.inp",
               'jobname'               :"_orca",
               'list_option'           : "medium",
               'listing_index'         : 1,
               'moinp'                 : "save.gbw",
               'newgto'                : None,
               'nprocs'                : 1,
               'num_explicit'          : 0,
               'old_moinp'             :"_orca.gbw",
               'optstr'                :'',
               'output'                :"_orca.out",
               'output_bqs'            :"_orca.pcgrad",
               'output_eandg'          :"_orca.engrad",
               'path'                  : '/public/home/baij/soft/orca_5_0_2_linux_x86-64_shared_openmpi411/orca',
                # v4.0 changed some basis set input conventions
               'version'               : 4.0,
             }

    _internals = {
                   '_basis_element' : [],
                   '_basis_list'    : '',
                   '_basis_sym'     : [],
                   '_ecp_list'      : '',
                   '_ecp_ncore'     : [],
                   '_ecp_sym'       : [],
                   '_exec_run_shell': True,
                   '_syscmd'        : 'orca',
                 }

    _synons = {
                'blyp' : 'becke88 lyp',
                'lda'  : 'slater vwn_5',
                's-vwn': 'slater vwn_5',
                'hf'   : 'hf',
                'dft'  : 'dft'
              }

    def getInpBuff(self):
        '''String buff containing the input information'''

        if self.frag.bqs:
            self.frag.nbqs = len(self.frag.bqs.coords)
            ncent = self.frag.natoms + self.frag.nbqs

        method = self._synons.get(self.method.lower())
        self.hamout = method

        strbuff = '#ORCA input file generated by ChemShell\n'
        strbuff += "! %s" % (self.functional)
		
        if self.d3:
             strbuff += " D3"
        if self.d4:
             strbuff += " D4"

        strbuff += " %s" % (self.convergence)
        strbuff += " %s\n" % (self.exchange)

        if self.cosmo:
            strbuff += "! COSMO(%s)\n" % (self.cosmo)

        #Parallel execution
        if self.nprocs > 1:
            strbuff += "%pal\n"
            strbuff += "  nprocs %s\n" % (self.nprocs)
            strbuff += "end\n"
        strbuff += "%maxcore 3000\n"

        #Specify the point charge file
        if self.frag.nbqs > 0:
            strbuff += "%pointcharges \"pointcharges.xyz\" \n"

        #Method
        strbuff += "%method\n"
        if self.enerflag:
            if self._gradients:
                strbuff += "  RunTyp Gradient\n"
            else:
                strbuff += "  RunTyp Energy\n"
        strbuff += "end\n"

        #Basis set
#         Determine if self.basis contains one or more basis, or if file type with newGTO info
#         Individual newGTO Basis info written after the atom in the 'coords' section
        if self.basis:
         words = self.basis.split()
#         case 1: one item in self.basis with global basis info 
         if (len(words) == 1):
          strbuff += "%basis\n"
          if self.version < 4.0:
            strbuff += "  Basis %s\n" % (self.basis)
          else:
            strbuff += "  Basis \"%s\" \n" % (self.basis)
	          #Auxiliary basis for RI method
          if self.auxbasis:
            if self.version < 4.0:
                strbuff += "  Aux %s\n" % (self.auxbasis)
            else:
                strbuff += "  Aux \"%s\" \n" % (self.auxbasis)
          strbuff += "end\n"
#         case 2: more than one item in self.basis but not read in from file
         if (len(words) > 1) and "\"" not in self.basis.lower():
          strbuff += "%basis\n"
          strbuff += "  %s\n" % (self.basis)
          if self.auxbasis:
            if self.version < 4.0:
                strbuff += "  Aux %s\n" % (self.auxbasis)
            else:
                strbuff += "  Aux \"%s\" \n" % (self.auxbasis)
          strbuff += "end\n"
#         case 3: basis set in file
         if (len(words) > 1) and "\"" in self.basis.lower():
          self.basisspec = True
          lines = self.basis.splitlines()
          num_basis = 0
          self._basis_sym = [None] * (self.frag.natoms+1) 
          self._basis_element = [None] * (self.frag.natoms+1)
          self._basis_list = [None] * (self.frag.natoms+1)
          for line in lines:
            if "\"" in line:
              num_basis += 1
              word = line.split("\"")
              self._basis_sym[num_basis] = word[1]
              self._basis_element[num_basis] = ''.join([k for k in word[1] if not k.isdigit()])
              self._basis_list[num_basis] = "newGTO \n"
            else:
              if (num_basis > 0):
                if ("newgto" not in line.lower()):
                    self._basis_list[num_basis] +="%s" % (line.rstrip())
                if ("end" not in line.lower()):
                    self._basis_list[num_basis] +="\n"
                
        #ECPs
        if self.ecp:
            num_ecp = 0
            j = ''
            self._ecp_ncore = [None] * (self.frag.natoms+1)
            self._ecp_sym = [None] * (self.frag.natoms+1)
            self._ecp_list = [None] * (self.frag.natoms+1)
            if os.path.isfile(os.path.abspath(self.ecp)):
#               ECP is in a file
                ecp_list = fileutils.file2text(self.ecp)
                lines = ecp_list.splitlines()
                for line in lines:
                  if "\"" in line:
                    num_ecp += 1
                    word = line.split("\"")
                    self._ecp_sym[num_ecp] = word[1]
                    j.join([k for k in word[1] if not k.isdigit()])
                    self._ecp_list[num_ecp] = "NewECP \n"
                  else:
                    if ("newecp" not in line.lower()):
                      self._ecp_list[num_ecp] +="%s\n" % (line)
                  if "core" in line.lower():
                    word = line.split()
                    self._ecp_ncore[num_ecp] = word[1]
            else:
#               ECP was defined in the input script
                lines = self.ecp.splitlines()
                for line in lines:
                    strbuff += line + '\n'
                    if "\"" in line:
                      num_ecp += 1
                      word = line.split("\"")
                      self._ecp_sym[num_ecp] = word[1]
                      j.join([k for k in word[1] if not k.isdigit()])
                      self._ecp_list[num_ecp] = "NewECP \n"
                    else:
                      if ("newecp" not in line.lower()):
                        self._ecp_list[num_ecp] +="%s\n" % (line)
                    if "core" in line.lower():
                      word = line.split()
                      self._ecp_ncore[num_ecp] = word[1]

        #SCF control
        strbuff += "%scf\n"
        strbuff += "  HFTyp %s\n" % (self.scftype)
        if self.restart:
            fileutils.rename(self.old_moinp,self.moinp)
            strbuff += "  Guess MORead\n"
            strbuff += "  MOInp \"%s\" \n" % (self.moinp)
        else:
#           Patom and Pmodel seem to fail when defining own Basis or ECP so defaulting to hueckel
            if self.guess:
                strbuff += f'  Guess {self.guess}\n'
            strbuff += "  AutoStart false\n"
            if self.broken:
                strbuff += f'  BrokenSym {self.broken}\n'
    
        if self.direct:
            strbuff += "  SCFMode Direct\n"
        else:
            strbuff += "  SCFMode Conventional\n"
    
        if self.maxiter:
            strbuff += "  MaxIter %s\n" % (self.maxiter)
    
        strbuff += "end\n"

        #Excited states
        if self.excited:
            if self.hamout == 'hf':
                strbuff += "%cis\n"
            elif self.hamout == 'dft':
                strbuff += "%tddft\n"
        
            # Must calculate as least as many roots as the state of interest
            if self.eroots > self.estate:
                strbuff += "  NRoots %s\n" % (self.eroots)
            else:
                strbuff += "  NRoots %s\n" % (self.estate)
            strbuff += "  IRoot %s\n" % (self.estate)
            strbuff += "end\n"

        #Geometry
        strbuff += "%coords\n"
        strbuff += "  CTyp xyz\n"
        strbuff += "  Mult %s\n" % (self.mult)
        strbuff += "  Units bohrs\n"
        strbuff += "  coords\n"

        #Point charge file
        if self.frag.nbqs:

            fp = open('pointcharges.xyz', 'w+')
            self.num_explicit = 0
            self.exp_list.clear() 
            num_file_bqs = 0
            ecprange = self.frag.bqs.getRegion(2)
            for i in range(self.frag.bqs.nbqs): 
#               This initial loop is to determine the number of bqs to be written in the pointcharges file, and removes the pointcharge(s)
#               that have to be treated differently (i.e. when requiring an 'explicit' interface)
                name = str(self.frag.bqs.names[i])
#               There's probably a neater way to strip the extraneous bits from the name but it'll do in a pinch
                name = name.replace(' ','')
                name = name.replace('\'','')
                name = name.replace('b','')
                coords = list(self.frag.bqs.coords[i])
                if (name not in self._ecp_sym):
                  num_file_bqs += 1
            fp.write(str(num_file_bqs))
            fp.write('\n')
            for i in range(self.frag.bqs.nbqs):
#               This loop writes the bq info into the pointcharges file.
                name = str(self.frag.bqs.names[i])
                name = name.replace(' ','')
                name = name.replace('\'','')
                name = name.replace('b','')
                coords = list(self.frag.bqs.coords[i])
                if (name not in self._ecp_sym):
#               Not an explicit ECP - added to pointcharges file
                  for j in range(3):
                      coords[j] = coords[j] / unitconvert.Angstrom2Bohr
                  fp.write('{0:3.10f} {1:3.10f} {2:3.10f} {3:3.10f}\n'.format(self.frag.bqs.charges[i], coords[0], coords[1], coords[2]))
                else:
#               Explicit ECP - added to main input file
                  element = '' 
                  element = element.join([k for k in name if not k.isdigit()])
                  atom_charge = self.frag.bqs.charges[i]
                  self.explicit = True
                  self.num_explicit += 1
                  self.exp_list.append(i)
                  strbuff += "%s> %s %s %s %s " % (element, atom_charge, coords[0], coords[1], coords[2])
                  for j in range(1,num_ecp+1):
                    if name in self._ecp_sym[j]:
                      strbuff += "\n%s" % (self._ecp_list[j])
            fp.close()

#           Due to the way the explicit ECPs are treated we need to remove the coulombic interaction between the explicit ECPs and the 
#           remaining bqs.
            self.energy_correction = 0.0
            test_e = 0.0
            for i in self.exp_list:
                coords_i = list(self.frag.bqs.coords[i])
                for j in range(self.frag.bqs.nbqs):
                  dist = 0.0
                  chargeprod = 0.0
                  coords_j = list(self.frag.bqs.coords[j])
                  chargeprod=-1.0 * self.frag.bqs.charges[i] * self.frag.bqs.charges[j]
                  for k in range(3):
                    dist += (coords_i[k] - coords_j[k])**2
                  dist = math.sqrt(dist) 
                  if dist and chargeprod:
                    if (j in self.exp_list) and (j > i):
                      test_e += chargeprod/dist
                    if j not in self.exp_list:
                      self.energy_correction += chargeprod / dist
            self.energy_correction += test_e

        for i in range(self.frag.natoms):
            coords = list(self.frag.coords[i])
            symbol = self.frag.names[i].decode('utf-8')#str(atomicdata.symbols[self.frag.znums[i]])
            element = str(atomicdata.symbols[self.frag.znums[i]])
#           Here we are checking if each element has an ECP, BASIS, both or neither and adding the appropriate info to strbuff
#           We need the differentiation as if ECP-only (treating as embedded shell) then the formatting is different
#           ORCA doesn't understand numbers after the element, so individual atom identification (for ECP and Basis assignment)
#           happens in the background with the 'symbol' variable.
            if self.ecp:
              shell_only = True 
              basis_only = True
              for j in range(1,num_ecp+1):
                if symbol in self._ecp_sym[j]:
                  basis_only = False
              if basis_only:
                strbuff += "%s %s %s %s " % (element, coords[0], coords[1], coords[2])
              else:
                if self.basisspec:
                  for k in range (1,num_basis+1):
                    if symbol in self._basis_sym[k]:
                      shell_only = False
                  if shell_only: #ECP only found for this atom (Implicit interface)
                      for j in range(1,num_ecp+1):
                        if symbol in self._ecp_sym[j]:
                            atom_charge = self.frag.znums[i] - int(self._ecp_ncore[j])
                            strbuff += "%s> %s %s %s %s " % (element, atom_charge, coords[0], coords[1], coords[2])
                  else: #ECPs used and basis found for this atom
                    strbuff += "%s %s %s %s " % (element, coords[0], coords[1], coords[2])
                else: #ECPs used but global basis used therefore not shell only
                  strbuff += "%s %s %s %s " % (element, coords[0], coords[1], coords[2])
            else: 
              strbuff += "%s %s %s %s " % (element, coords[0], coords[1], coords[2])
            if self.basisspec:
              for j in range(1,num_basis+1):
                if symbol in self._basis_sym[j]:
                  strbuff += "\n%s" % (self._basis_list[j])
            if self.ecp:
              for j in range(1,num_ecp+1):
                if symbol in self._ecp_sym[j]:
                  strbuff += "\n%s" % (self._ecp_list[j])
            strbuff += "\n"

        strbuff += "  end\n"
        strbuff += "  Charge %s\n" % (self.charge)
        strbuff += "end\n"

        #User-defined options
        if self.optstr:
            strbuff += "%s" % (self.optstr)

        return strbuff


    @property
    def runargs(self):
        '''Override the default runargs'''

        # YL 09/11/2021: because ORCA uses OpenMPI and it's very likely ChemShell is driven by Intel MPI
        #                we need --oversubscribe to prevent the error
        #                "There are not enough slots available in the system to satisfy..."
        #                and --mca btl_base_warn_component_unused 0 to suppress the warning
        #                "unable to find any relevant network interfaces"
        if self.nprocs > 1:
            return f'{self.input} "--oversubscribe --mca btl_base_warn_component_unused 0"'
        else:
            return self.input


    def setOutKeys(self):
        '''Define {task:keyword} for searching in output file'''

        if self.frag.bqs:
            self.frag.nbqs = len(self.frag.bqs.coords)
            ncent = self.frag.natoms + self.frag.nbqs

        # each keyword should contain an array of integers specifying:
        #     [ row_0, # starting row
        #       row_n, # ending row
        #       row_i, # row increment
        #       col_0, # starting col
        #       col_n, # ending col
        #       col_i, # col increment
        #       skip , # skip the previous (skip-1) match,
        #       coeff, # unit conversion coefficient
        #     ]
        # referencing to the line where the key is matched
        if self.broken:
         self._outkeys = {
                          "energy"   : {"Total Energy":[0,0,1,3,3,1,2,1.0]},
                          "gradients": {"current gradient":[2,(1+3*(self.frag.natoms+self.num_explicit)),1,0,0,1,1,1.0]},
                          "bq_grads" : {"":[1,(self.frag.bqs.nbqs-self.num_explicit),1,0,2,1,1,1.0]},
                        }
        else:
         self._outkeys = {
                          "energy"   : {"Total Energy":[0,0,1,3,3,1,1,1.0]},
                          "gradients": {"current gradient":[2,(1+3*(self.frag.natoms+self.num_explicit)),1,0,0,1,1,1.0]},
                          "bq_grads" : {"":[1,(self.frag.bqs.nbqs-self.num_explicit),1,0,2,1,1,1.0]},
                        }


    def parseMainOutput(self):
        '''Parse main output file self.output '''

        from ...utils import fileutils
        
        self.setOutKeys()

        self._result.energy    = fileutils.getArrayFromFile(self.output, 'out', self._result.energy.shape   , regex=self._outkeys['energy'])
        # If Explicit interface, need to remove BQ-BQ interaction
        if self.explicit:
          self._result.energy += self.energy_correction 

        if self._gradients and os.path.isfile(os.path.abspath(self.output_eandg)):
            temp_grad = zeros(shape=(self.frag.natoms+self.num_explicit,3))
            temp_grad = fileutils.getArrayFromFile(self.output_eandg, 'out', (self.frag.natoms+self.num_explicit, 3), regex=self._outkeys['gradients'])
            for i in range (self.frag.natoms+self.num_explicit):
              if (i >= self.num_explicit):
                self._result.gradients[i-self.num_explicit] = temp_grad[i] 

        if self._gradients and self.frag.nbqs:
            if os.path.isfile(os.path.abspath(self.output_bqs)):
               if self.explicit:
#              If this involves explicit interface, then the bq-bq forces need to be removed
                 self.frag.bqs.gradients = 0.0
                 temp_grads = zeros(shape=(self.frag.bqs.nbqs-self.num_explicit,3))
                 temp_grads = fileutils.getArrayFromFile(self.output_bqs, 'out', (self.frag.bqs.nbqs-self.num_explicit,3), regex=self._outkeys['bq_grads'])
                 exp_counter = 0
                 counter = 0
                 for i in range(self.frag.bqs.nbqs):
                   if i in self.exp_list:
                     self.frag.bqs.gradients[i] = temp_grad[exp_counter]
                     exp_counter += 1
                   else:
                     self.frag.bqs.gradients[i] = temp_grads[counter]
                     counter += 1
                 for i in self.exp_list:
                   coords_i = list(self.frag.bqs.coords[i])
                   for j in range(self.frag.bqs.nbqs):
                     chargeprod = 0.0
                     dist = 0.0
                     coords_j = list(self.frag.bqs.coords[j])
                     chargeprod=-1.0 * self.frag.bqs.charges[i] * self.frag.bqs.charges[j]
                     for k in range(3):
                       dist += (coords_i[k] - coords_j[k])**2
                     dist = math.sqrt(dist) 
                     if (j != i):
                       correction = chargeprod / (dist**3)
                       if (j in self.exp_list) and (j > i):
                         for k in range(3):
                           diff = coords_j[k] - coords_i[k]
                           self.frag.bqs.gradients[i][k] += correction  * diff
                           self.frag.bqs.gradients[j][k] -= correction  * diff
                       if j not in self.exp_list:
                         for k in range(3):
                           diff = coords_j[k] - coords_i[k]
                           self.frag.bqs.gradients[i][k] += correction * diff
                           self.frag.bqs.gradients[j][k] -= correction * diff

               else:
                 self.frag.bqs.gradients = fileutils.getArrayFromFile(self.output_bqs, 'out', self.frag.bqs.gradients.shape, regex=self._outkeys['bq_grads'])



```
qm.py
```
#  Copyright (C) 2017 The authors of Py-ChemShell
#
#  This file is part of Py-ChemShell.
#
#  Py-ChemShell is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as
#  published by the Free Software Foundation, either version 3 of the
#  License, or (at your option) any later version.
#
#  Py-ChemShell is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with Py-ChemShell.  If not, see
#  <http://www.gnu.org/licenses/>.

import chemsh

from .         import _Interfaces
from ..base    import run
from ..io      import keyword
#from ..objects import Fragment
from ..utils   import fileutils, miscutils, modutils

# inherit <ctypes.Structure> type for convenience of making callback
class _QM(_Interfaces):
    '''A container of QM methods: all QM interfaces should be of this class'''

    from ctypes import RTLD_GLOBAL
    from ..cluster import partition

    # default mode for ctypes.CDLL() function, see modutils
    _mode = RTLD_GLOBAL

    _attrs = {
               'analysis'         :'',       # wavefunction analysis
               'atom_names'       :'ff',
               'basis'            :'',  # also use `basis` to control `basisspec`
               'charge'           : 0,
               'damping'          : True,
               'diis'             : True,
               'direct'           : True,
               'broken'           : '',
               'dispersion'       : '',
               'ecp'              : '',      # AJL, Aug2017. Used by more than one calculator so included here rather than in child classes
               'ecps'             : None,    # needed by NWChem Fortran code, otherwise could've been kept private
                # YL 18/11/2019: changed to a user option at QM interface level again and removed from QMMM
               'ecp_region'       : partition._attrs['label_interface'],
               'functional'       :'blyp',
               'ghost'            :[],
               'ghost_prefix'     :'X_',
               'grid'             :'medium',
               'guess'            :'',
               'harmonic'         : False,
               'input'            : None,    # dummy definition, to be overwritten by calculator (Needed for FHI-aims interface)
               'level_shift'      : False,
               'level_e1'         : 1.0,
               'level_e2'         : 0.3,
               'level_cycles'     : 999,
               'logger'           :'',       # error logger for stderr
               'maxiter'          : 100,
               'method'           :'dft',
               'mult'             : 0,
               'necps'            : 0,
               'nstates'          : 0,
               'path'             :'',
               'pop_analysis'     :'',       # HNT, Jul2020. Added population analysis keyword for mulliken.
               'properties'       :'',
               'pseudopotential'  :'',
               'restart'          : False,
               'root_state'       : 0,
               'threshold'        : 1.0e-6,
               'scale_nonperiodic': 3.0,
               'scftype'          :'rhf',
               'separate_ecps'    : False,   # YL 18/11/2019: changed to a user option at QM interface level again and removed from QMMM
               'spin'             :'singlet',
               'sysmpi'           :'',
             }

    _internals = {
                   '_ecp_charge'   : 1.0E-8,
                   '_syscmd'       : '',
                   '_extra_outputs': [],
                   '_recalc_cell'  : True,
                   '_qmme'         : 0,
                 }

    # set up at the QM/MM level
    @property
    def linkatoms(self):
        '''List of link atom indices'''

        return self._linkatoms


    # called by run.runExec()
    def genInput(self, **kwargs):
        '''Generate input'''

        from ..utils import fileutils

        # single input file
        if type(self.input) in [ str ]:
            fileutils.write(self.input, self.getInpBuff())

        # multiple input files
        elif type(self.input) in [ list, tuple ]:
            for input in self.input:
                fileutils.write(input, self.getInpBuff(input=input))


    def parseMainOutput(self):
        '''Parse main output file self.output'''

        # do nothing in QM template


    def parseAdditionalOutput(self):
        '''Parse additional output data, e.g., nwchem.bq_grads. This procedure could be overloaded, otherwise ignored.'''


    def setOutKeys(self):
        '''Set up {task:keyword} for output parsing. Shall be overloaded if needed.'''


    def parseOutput(self):
        '''Parse output'''

        self.parseMainOutput()

        self.parseAdditionalOutput()


    @miscutils.time
    def run(self, **kwargs):
        '''Single-point procedure'''

        from sys     import stderr, stdout
        from ..utils import fileutils
        from ..io    import banner, format
        from ..data  import references

        if not self.frag.natoms:
            print("\n\n >>> ChemShell ERROR: no valid fragment has been assigned to theory {}!\n\n".format(self.__class__.__name__))
            exit(999)

        fileutils.archiveFile(self.input)
        fileutils.archiveFile(self.output)

        banner.printModuleBanner(f'ChemShell/{self.__class__.__name__} Interface', level=2)
#        if self.__class__.__name__.lower() in references.references:
#            print(' Please cite:')
#            format.printwrap(references.references[self.__class__.__name__.lower()], prepend_blanc_line=False)

        if chemsh.CHEMSH_DEBUG > 4:
            print(" {} debug mode:".format(__class__))
            print(" path         = {}".format(self.path))
            print(" getLinkedLib = {}".format(modutils.getLinkedLib(self.__class__.__name__, mode=self._mode)))
            print(" syscmd       = {}".format(self._syscmd))

        # YL: we allow users to override linked-in libs with `path`: check path first then isLinked then _syscmd
        cmdpath = self.path or modutils.getLinkedLib(self.__class__.__name__, mode=self._mode) or self._syscmd

        # don't use higher level task routines here (need to keep lower level separate)
        # all keyword arguments at the run() step will be temporary
        # YL 11/2020: run twice for the QM/Me periodic embedding scheme
        if self._qmmm_scheme == "qm/me":
            ierror = self.__runQMMe(cmdpath, **kwargs)

        # standard methods
        else:
            ierror = run.run(self, cmdpath, stderr=self.logger, shell=self._exec_run_shell, **kwargs)
            stdout.flush()
            stderr.flush()

        # combine the BQ gradients with contribution from separate ECPs
        if self.necps and self.separate_ecps and self._gradients and kwargs.get('_gradients', False) != 'shells':
            # YL 25/07/2021: planned to change to `self.frag.bqs.gradients[self._ecps._range] += self._ecps.gradients`
            #                this should be safe because self._ecps depends on self.bq.coords only which is not changed during QM.run()
            self.frag.bqs.gradients[self.ecps._range] += self.ecps.gradients

        # flush output
        return ierror


    @property
    def logger(self):
        '''Error logger filename'''

        if not self._logger:
            return '_{}.err'.format(self.__class__.__name__.lower())
        else:
            return self._logger


    @logger.setter
    def logger(self, val):
        '''Setter of logger'''

        self._logger = val


    @property
    def runargs(self):
        ''''''

        try:
            return self._runargs
        except:
            # default is just self.input
            return self.input


    @runargs.setter
    def runargs(self, val):
        '''Setter of runargs'''

        self._runargs = val


    @property
    def restart(self):
        '''Restart from a previous calculation'''

        return self._restart


    @restart.setter
    def restart(self, val):
        '''Setter of restart'''

        self._restart = val


    @property
    def _underscored_name(self):
        ''''''

        return '_' + self.__class__.__name__.lower()


    @property
    def _extrafiles(self):
        '''Additional output files'''

        return []


    @property
    def path(self):
        '''Path of command to execute the code'''

        return self._path


    @path.setter
    def path(self, val):
        '''Setter of path'''

        self._path = val


    # YL 22/08/2019: we hope to deal with ghost atoms' basis set automatically
    def getBasisWithGhost(self):
        '''Automatically adapt basis set for ghost atoms'''

        from numpy import char, unique, setxor1d

        strbuff = self.basis

        if len(self.ghost) > 0:
            lstrbuff = strbuff.splitlines()
            ghostbuff = '\n# ghost basis set adapted by Py-ChemShell\n'
            ghost_species = char.decode(unique(self.frag.names[self.ghost]))

            lastline = len(lstrbuff)
            for i, l in enumerate(lstrbuff):
                if l.strip().lower().startswith('end'):
                    lastline = i
                    break
            defined_ghosts = []
            # check if already defined
            for g in ghost_species:
                for i, l in enumerate(lstrbuff):
                    if l.strip().lower().startswith(self.ghost_prefix.lower()+g.lower()):
                        print(" \n Basis set for ghost atom \"{}\" detected.\n".format(self.ghost_prefix+g))
                        defined_ghosts += [g]
                        break

            # loop over ghost atoms
            for g in setxor1d(ghost_species, defined_ghosts):
                print(" Adapting basis set for ghost atom \"{}\"...".format(self.ghost_prefix+g))
                ghostbuff += '\n# {}\n'.format(self.ghost_prefix+g)
                # find starting line
                other_species = setxor1d(char.decode(unique(self.frag.names)), [g])
                for i, l in enumerate(lstrbuff):
                    if l.strip().lower().startswith(g.lower()):
                        startline = i
                        break
                # find ending line by matching the first other species
                endline = len(lstrbuff)
                for o in other_species:
                    for i, l in enumerate(lstrbuff[startline+1:]):
                        if l.strip().lower().startswith(o.lower()) and endline>startline+i+1:
                            endline = startline+i+1
                        if l.strip().lower().startswith('end') and endline>startline+i+1:
                            endline = startline+i+1
                            break
                for i, l in enumerate(lstrbuff[startline:endline]):
                    if l.strip().lower().startswith(g.lower()):
                        ghostbuff += self.ghost_prefix + l.strip() + '\n'
                    # get rid of comments
                    elif l.strip().startswith("#"):
                        continue
                    elif l.strip() == '':
                        continue
                    else:
                        ghostbuff += l+'\n'
            lstrbuff.insert(lastline, ghostbuff)
            strbuff = '\n'.join(lstrbuff)

        return strbuff


    @property
    def basis(self):
        '''Basis set: returns a standard name of basis set or the content of basisdeck or whats given'''

        from ..data  import basis
        from ..utils import fileutils
        
        # search in the standard basis set names, if not found return the content of string or file
        return basis.basissets.get(self._basis.strip().lower().replace('-',''),
                                   fileutils.file2text(self._basis, preceding_newline=True, error_return=self._basis))
        # search in the standard basis set names, if not found return the content of string or file
        strbuff = basis.basissets.get(self._basis.strip().lower().replace('-',''),
                                      '\n'+fileutils.file2text(self._basis, error_return=self._basis))

        return strbuff


    @basis.setter
    def basis(self, val):
        '''Setter of basis'''

        self._basis = val


    @property
    def ghost(self):
        '''Ghost atoms'''

        return self._ghost
       

    @ghost.setter
    def ghost(self, val):
        '''Setter of ghost'''

        from numpy   import unique
        from ..utils import iterutils

        self._ghost = iterutils.getFlattened([val])

        nghosts = len(self._ghost)

        # can't print names before frag may not be ready
        if nghosts == 1:
            print(" >>> {}: ghost atom {} requested".format(self.__class__.__name__, self._ghost))
        elif nghosts > 1:
            print(" >>> {}: ghost atoms {} requested".format(self.__class__.__name__, self._ghost))


    @property
    def functional(self):
        '''DFT functional'''

        from ..data import dft

        return dft.functionals.get(self._functional.lower().replace('-',''),
                                   self._functional.lower())


    @functional.setter
    def functional(self, val):
        '''Setter of functional'''

        self._functional = val


    @property
    def grid(self):
        '''Grid accuracy'''

        selectcases = { 'low'      :'low',
                        'medium'   :'medium',
                        'high'     :'high',
                        'veryhigh' :'veryhigh',
                        'ultrahigh':'ultrahigh',
                      }

        return selectcases.get(self._grid.lower(), '')


    @grid.setter
    def grid(self, val):
        '''Setter of grid'''

        self._grid = val


    @property
    def pop_analysis(self):
        '''Defines population analysis methods'''

        analysis_method = { 'mulliken' : 'mulliken',
                            'fukui' : 'fukui', 
                          }

        return analysis_method.get(self._pop_analysis.lower(), '')


    @pop_analysis.setter
    def pop_analysis(self, val):
        '''Setter of population analysis method'''
        self._pop_analysis = val



    @property
    def scftype(self):
        '''Type of SCF'''

        # default is RHF for singlets and UHF for higher spin multiplicities
        if not self._scftype:
            if self.mult == 1:
                return 'rhf'
            else: 
                return 'uhf'

        return self._scftype


    @scftype.setter
    def scftype(self, val):
        '''Setter of SCF type'''

        self._scftype = val


    # YL 18/11/2019: removed from _attrs
    @property
    def necps(self):
        '''Number of ECP point charges'''

        try:
            return self.ecps._master.shape[0]
        except:
            return 0


    # only used by initialisation
    @necps.setter
    def necps(self, val):
        '''Setter of necps'''


    # YL 18/11/2019: refactored
    @property
    def ecps(self):
        '''An instance of <class BQs> for separate ECPs'''

        from numpy import array, in1d

        # return if already defined to avoid adding/subtracting _ecp_charge for more than once
        try:
            #  YL 25/04/2020: update coordinates of ECPs (for separate ECPs where shells are retained)
            self._ecps.coords = self.frag.bqs.coords[self._ecps._range]
            return self._ecps

        except:

            # requested
            if self.separate_ecps:
                try:
                    # BQs.select() has problems with methods such as selectByRadius()
                    ecp_range = self.frag.bqs.selectByRegions(self.ecp_region)
                    # exclude shell centres in separate EPCs
                    shl_range = array(self.frag.bqs.stacks['Shells'])
                    ecp_range = ecp_range[in1d(ecp_range, shl_range, invert=True)]
                    if len(ecp_range):
                        self._ecps = self.frag.bqs.getSelected(ecp_range)
                        self._ecps._range = ecp_range
                        self._ecps.charges = self._ecp_charge
                    else:
                        self._ecps = None
                except:
                    self._ecps = None

            # not requested 
            else:
                self._ecps = None

            return self._ecps


    # only used by initialisation
    # AJL, June2020: This doesn't contain any actions? Is this safe?
    # YL 25/07/2021: it was safe thanks to the try-except clause but added `self._ecps = val` now
    @ecps.setter
    def ecps(self, val):
        '''Setter of ecps'''

        self._ecps = val


    @property
    def mult(self):
        '''Multiplicity (automatically calculated but can be overridden)'''

        from ..base import forcefield

        if self._mult > 0:
            return self._mult

        else:
            znum = forcefield.names2znums(self.frag.names).sum()
            return (znum - self.charge)%2 + 1


    @mult.setter
    def mult(self, val):
        '''Setter of mult'''

        self._mult = val


    @property
    def _time_dependent(self):
        '''Return True if time-dependent excited state calculations are requested'''

        # supported time-dependent methods
        if self.method.lower() in [ 'td-dft', 'td-hf', 'tddft', 'tdhf' ]:
            return True
        else:
            return False


    @property
    def _excited_state(self):
        '''Return True if time-dependent excited state calculations are requested'''

        # supported methods
        if self._time_dependent or self.method.lower() in [ 'mrci', 'mr-ci', 'ccsd', 'ccsdt', 'casscf', 'caspt2' ]:
            return True
        else:
            return False


    @property
    def nstates(self):
        '''Number of states requested'''

        # defaults to 3 if not set by the user
        if self._excited_state and not self._nstates:
            self._nstates = 3

        return self._nstates


    # YL: it won't work if we initialise self._result.excitations by resizing
    #     because `_attrs` are processed before `_internals` and `self._result`
    #     will be overwritten anyway
    #     so we need to override the _result() method to include multistate results
    @nstates.setter
    def nstates(self, val):
        '''Setter of nstates'''

        self._nstates = val


    def __runQMMe(self, cmdpath, **kwargs):
        '''Run QM/Me method for periodic embedding'''

        from sys    import stdout
        from copy   import copy as pycopy
        # YL 10/02/2021: gcd is not available until NumPy v1.15
        #                temporarily use math.gcd
        from numpy  import arange, array, copy
        from math   import gcd
        from ..base import lattice
        from ..io   import format

        # choose a surface
        try:
            # should be already determined by <class QMMM>
            surface = self._surface
        except:
            print("\n WARNING: no surface has been chosen so \"{}\" will be used as default\n".format('ab'))
            self._surface = 'ab'
            surface = self._surface

        # non-periodic dimension
        dimension = lattice.dimensions[surface]

        # remember filenames
        input  = pycopy(self.input)
        output = pycopy(self.output)

        print(' '+'-'*70)
        print("\n QM/Me scheme: running the 1st QM calculation with adsorbate\n")
        print(' '+'-'*70)
        stdout.flush()

        # cell.vectors were used implicitly, which were created in QMMM.qm
        # recalculate the lattice constants in the beginning
        consts = array(self.frag.getLatticeOfSelectedPeriodic(arange(self.frag.natoms), surface=surface, recalculate=True))

        if self._recalc_cell:
            # scale the non-periodic vector to make sure the volume is large enough
            # NB: this is required for some codes such as CP2K
            self.frag.cell.consts = [ p*self.scale_nonperiodic if i == dimension else p for i, p in enumerate(consts) ]
        else:
            self.frag.cell.consts = self.__saved_consts[:]

        # calculate padding distance (unit vector length) along periodic dimensions if the code doesn't allow redundant centres in cell (e.g., CP2K)
        # NB: the cell fragment must be correctly prepared without redundant centres otherwise the calculation will be wrong!
        if not self._cell_redundant and self._recalc_cell:
            # always reset vectors before calculating constants! otherwise constants are wiped according to vectors!
            self.frag.cell.vectors[:] = 0.0

            # calculate the unit vector lengths: do NOT include adsorbate atoms!
            padded_consts = array(self.frag.getLatticeOfSelectedPeriodic(arange(self.frag.natoms)[self._non_adsorbate],
                                                                         surface     = surface,
                                                                         accuracy    = 0.5,
                                                                         recalculate = True,
                                                                         redundant   = self._cell_redundant))

            # apply the padding to the periodic vectors
            self.frag.cell.consts = [ p if i != dimension else self.frag.cell.consts[i] for i, p in enumerate(padded_consts) ]

        # save the constants to keep them constant for all following runs because
        if self._recalc_cell:
            a, b, c, alpha, beta, gamma = [ self.frag._cell.a, self.frag._cell.b, self.frag._cell.c, self.frag._cell.alpha, self.frag._cell.beta, self.frag._cell.gamma ]
            self.__saved_consts = [ a, b, c, alpha, beta, gamma ]
            # keep a copy of original cell vectors for use in the second run
            self.__saved_vectors = copy(self.frag.cell.vectors)

        a, b, c, alpha, beta, gamma = [ self.frag._cell.a, self.frag._cell.b, self.frag._cell.c, self.frag._cell.alpha, self.frag._cell.beta, self.frag._cell.gamma ]
        print(format.wrap("Lattice constants (a.u.) of the selected periodic QM region automatically assigned:"))
        print(" a     = {:>15.6f}".format(a))
        print(" b     = {:>15.6f}".format(b))
        print(" c     = {:>15.6f}".format(c))
        print(" alpha = {:>15.6f}".format(alpha))
        print(" beta  = {:>15.6f}".format(beta))
        print(" gamma = {:>15.6f}".format(gamma))

        # the k-points sampling along the two periodic directions
        if self._recalc_kpoints:
            two_points = tuple(k for i, k in enumerate(self.kpoints) if i != dimension)
            # check the greatest common diviser
            # YL 11/02/2021: numpy.gcd() not available until NumPy v1.15
            d = gcd(*two_points)
            kpoints = tuple(k for k in self.kpoints)
            # set the k-points sampling 1 along the unperiodic direction
            self.kpoints = tuple(int(k/d) if i != dimension else 1 for i, k in enumerate(kpoints))

        # first run with adsorbate
        self.wavefunction = '_{}.wfn.w_adsorbate'.format(self.__class__.__name__.lower())
        fileutils.archiveFile(self.input +'.w_adsorbate')
        fileutils.archiveFile(self.output+'.w_adsorbate')

        # temporary filenames (will be restored after use)
        self.input  = input +'.w_adsorbate'
        self.output = output+'.w_adsorbate'

        ierror = run.run(self,
                         cmdpath,
                         stderr=self.logger,
                         # special options per QM interface
                         _qmme=1,
                         **kwargs,
                        )

        # geometry optimisation (DL_FIND) archiving because we cannot do with the temporary filenames there
        try: 
            if chemsh.CHEMSH_DEBUG:
                fileutils.archiveFile([self.input, self.output], dir=self._archive_dir, suffix=self._archive_suffix)
        except:
            pass

        e1 = pycopy(self._result.energy[0])
        print("\n QM/Me scheme: 1st QM energy (with adsorbate): {} a.u.\n".format(e1))

        print(' '+'-'*70)
        print("\n QM/Me scheme: running the 2nd QM calculation without adsorbate\n")
        print(' '+'-'*70)

        self.frag = self.frag.getSelected(self._non_adsorbate)

        # restore cell constants/vectors as they should be kept constant
        self.frag.cell.vectors[:] = self.__saved_vectors
        self.frag.cell.consts = self.__saved_consts[:]

        a, b, c, alpha, beta, gamma = [ self.frag._cell.a, self.frag._cell.b, self.frag._cell.c, self.frag._cell.alpha, self.frag._cell.beta, self.frag._cell.gamma ]
        print("\n Lattice constants (a.u.) of the selected periodic QM region automatically assigned:")
        print(" a     = {:>15.6f}".format(a))
        print(" b     = {:>15.6f}".format(b))
        print(" c     = {:>15.6f}".format(c))
        print(" alpha = {:>15.6f}".format(alpha))
        print(" beta  = {:>15.6f}".format(beta))
        print(" gamma = {:>15.6f}".format(gamma))

        # second run without adsorbate
        self.wavefunction = '_{}.wfn.wo_adsorbate'.format(self.__class__.__name__.lower())
        fileutils.archiveFile(self.input +'.wo_adsorbate')
        fileutils.archiveFile(self.output+'.wo_adsorbate')

        # temporary filenames (will be restored after use)
        self.input  = input +'.wo_adsorbate'
        self.output = output+'.wo_adsorbate'

        # TODO: codes that do not have these keywords
        ierror = run.run(self,
                         cmdpath,
                         stderr=self.logger,
                         # special options per QM interface
                         _qmme=2,
                         **kwargs,
                        )

        # geometry optimisation (DL_FIND) archiving because we cannot do with the temporary filenames there
        try: 
            if chemsh.CHEMSH_DEBUG:
                fileutils.archiveFile([self.input, self.output], dir=self._archive_dir, suffix=self._archive_suffix)
        except:
            pass

        # restore filenames
        self.input  = input
        self.output = output

        self._recalc_cell = False

        e2 = pycopy(self._result.energy)
        print("\n QM/Me scheme: 2nd QM energy (without adsorbate): {} a.u.\n".format(e1-self._result.energy[0]))

        return ierror


    # YL: override `_Interface._result` to enable multistate results
    @property
    def _result(self):
        '''Result containing energy and gradients'''

        from ..objects import result

        # associated to task.result
        try:
            # initialise the multi-state result array (in-place operation)
            if self.__result.excitations.size != self.nstates:
                self.__result.excitations.resize(self.nstates, refcheck=False)
            return self.__result

        # for example: when a QM/MM task does not initialise task.qmmm.qm._result or task.qmmm.mm._result
        except:
            self.__result = result.Result()
            self.__result.excitations.resize(self.nstates, refcheck=False)
            return self.__result


    @_result.setter
    def _result(self, val):
        '''Setter of result'''

        self.__result = val

```


        


